Конфигурации панорам по ФБ:
(сейчас в редакторе мы ставим угол <=180)

6000x1217
    hfov 180 - дополняем до height=2434
    hfov 360 - Facebook guide

6000x1781
    hfov 180 - дополняем до height=3562
    hfov 360 - Facebook guide

6000x2137
    hfov 180 - дополняем до 3562
    hfov 300 - Facebook guide

6000x2671
    hfov 180 - дополняем до 3562
    hfov 240 - Facebook guide

6000x3562
    hfov 180 - FacebookGuide (без изменений)

6000x4274
    hfov 150 - FacebookGuide (без изменений)

6000x5343
    hfov 120 - Facebook Guide (без изменений)

HFOV (Horizontal field of view) горизонтальный угол обзора.
Панорамы запощены с комментом типа 6000x1781_360, где последнее число это HFOV. От него сильно меняется восприятие одной и той же картинки.
Рассуждение только по официальному гайду Facebook. Без учета "загадочных" панорам с iPhone.
1) Можем дать настройку: круговая панорама или нет. Чем больше угол hfov тем больше чувствуется скругление, изгиб панорамы. То есть будет слишком большой изгиб, будет некомфортно. Зато не будет полос.
2)


TODO:
Копятся обработчики Engine.on при пересоздании контролов.
Автотесты для нового функционала
Нормализация left top пинов в зависимости от размеров картинки
При добавлении каждого следующего пина контрол ClickAndAddToArray инитится всё большее число раз.


Проблемы:
-Изменение свойства (в частности контролом TextQuickInput) вызывает перезапуск приложение, далее рендер, далее обновление экранов, контролов и сброс фокуса с компонента.
    Решение, параметр restartApp=false
        - Буфер изменененых свойств ... Или установка свойства сразу в приложение?
-Когда свойство обновляется (pins[0].data.text), оно должно обновляться и в свойстве pins. Для этого только new app(), createAppproperties()
        - Дубликат приложение?
        - Вычислять зависимые проперти в createAppProperties
-Один и тот же селектор id=mm pins для разных rules, создания и удаления массива. Конфликт аппПроперти

-ClickAnAddToArray обрабатывает клик в то время как происходит клик на pin_wr, так как теперь есть селектор id=mm pins
    Обработка клика есть также в bindControlsForAppPropertiesOnScreen

Сомнения:
Просто createAppScreens слишком примитивно при render экрана?

Что иметь ввиду:
Drag: отменил установку setValue в процессе move
Drag: закомментил stopPropagation
Drag: updateScreens изменил ?
Создал TextQuickInputDraggable зачем то

Сделано.
onAppChange: renderChecksum
Мигание пина после перетаскивания происходит. Выяснить
    - Не соблюдался масштаб при Drag:onPropertyChanged контрол улетал за область потом возвращался из-за пересоздания экрана
seletion update при драге и вводе
addArrayElement deleteArrayElement переделать на значение из propertyValue а не приложения
Сделал возможность в дескрипторе selector== id=mm pins(createPins) делать + getAppProperty(propertyStringOrSelector)
drag доп параметр
drag updateSelection updateQuickPanelPosition
Кастомный паблишер